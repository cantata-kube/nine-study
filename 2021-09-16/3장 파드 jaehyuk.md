# 3장 파드: 쿠버네티스에서 컨테이너 실행

## 파드
- 함께 배치된 컨테이너 그룹, 기본 블록

- 컨테이너를 가진 파드를 배포하고 운영한다고 생각하면 된다.

- 일반적으론 파드에 하나의 컨테이너가 들어가지만 컨테이너가 여러개인 파드는 특정 노드 내에서만 실행된다. (한 파드 안의 컨테이너들이 서로 다른 노드에 걸쳐 실행되지 않는다는 말)
<br/><br/>

### 파드가 필요한 이유 (여러 프로세스를 실행하는 단일 컨테이너보다 다중 컨테이너가 나은 이유)

- 예시: IPC나 로컬 파일을 통해 통신하는 여러 프로세스로 구성된 애플리케이션
  - 이런 애플리케이션은 단일 컨테이너에서 실행하는 것이 좋아보이지만 그렇지 않음
  
  - 이유:
    1. 위 상황에서 프로세스 중 하나라도 실패하면 컨테이너 자체를 다시 실행해야 하는 경우가 생김
    2. 컨테이너 안의 모든 프로세스는 동일한 표준 출력으로 로그를 기록하기 때문에 어떤 프로세스가 남긴 로그인지 파악하는 것이 매우 힘듬
   
  - 이것이 도커와 쿠버네티스를 사용하는 방법이자 이유인듯
<br/><br/>

### 파드 이해하기
    여러 프로세스를 단일 컨테이너 안에 넣지 않기 때문에 컨테이너들을 함께 묶고 하나의 단위로 관리할 수 있는 상위구조가 파드
<br/>

- 같은 파드내에서 컨테이너 간 부분 격리
  - 같은 파드 내에서의 각 컨테이너는 완벽하게 격리되지 않도록 한다. (특정 리소스를 공유)

  - k8s는 파드 안의 컨테이너들이 자체 네임스페이스가 아닌 동일한 리눅스 네임스페이스를 공유하도록 도커를 설정한다.

  - 모든 컨테이너 들이 동일한 네트워크 네임스페이스와 UTS 네임스페이스안에서 실행되기 때문에 모든 컨테이너는 호스트 이름과 네트워크 인터페이스를 공유한다. (동일한 IPC 네임스페이스 아래에서 IPC를 통해 서로 통신이 가능)

  - 파일 시스템은 좀 다름. 컨테이너 파일 시스템은 보통 컨테이너 이미지에서 나오기에 기본적으로 파일시스템은 다른 컨테이너와 완전히 분리, 여기서는 볼륨 개념을 통해 컨테이너끼리 파일 디렉터리를 공유한다.

- 컨테이너가 동일한 IP와 포드 공간을 공유하는 방법
  - 파드 안의 컨테이너는 동일한 네트워크 네임스페이스에서 실행되기 때문에, 동일한 IP 주소와 포트 공간을 공유 -> 파드 안 컨테이너에서 실행 중인 프로세스는 같은 포트 번호를 사용하지 않도록 주의해야 함 (포트충돌 주의할 것)

- 파드 간 플랫 네트워크
  - k8s 클러스터의 모든 파드는 하나의 플랫한 공유 네트워크 주소 공간에 상주하므로 모든 파드는 다른 파드의 IP 주소를 사용해 접근하는 것이 가능.

  - 파드 사이엔 NAT 존재 X, 11장에서 본 파드 간 통신
  
  - 파드 끼리의 통신은 단순, 두 파드가 동일 혹은 서로 다른 워커노드에 있는지는 중요하지 않다. 같은 LAN 상의 PC가 통신하는 느낌으로 보면 된다.

<br/><br/>

### 파드에서 컨테이너의 적절한 구성
애플리케이션을 여러 파드로 구성하고 각 파드 안에서는 밀접하게 관련 있는 구성 요소나 프로세스만 포함되게 하자.

프론트 서버 / 백엔드 DB로 구성된 다른 계층 애플리케이션을 배포할 때 어떤식으로 파드 구성을 할 지 생각해보자.

- 다계층 애플리케이션을 개별 확장이 가능하게 여러 파드로 분할
  - 프론트/백엔드가 같은 파드 내에 있다면 워커노드를 하나만 사용하게 되어 다른 워커노드는 사용하지 않게 된다. -> 자원 낭비
  
  - 스케일링 또한 중요한 이유가 된다.
    - 우선 k8s에선 파드 자체를 수평으로 확장해야함, 여기서 위 예시를 참고하면 프론트 / 백을 파드에 각각 담았을 때, 개별적으로 scale out을 할 수 있는 이점이 있다.

- 파드에서 여러 컨테이너를 사용하는 경우 
  - 주된 이유는 애플리케이션이 하나의 주요 프로세스와 하나 이상의 보완 프로세스로 구성된 경우
   ![image](https://user-images.githubusercontent.com/38865267/133540302-523d8cac-97cf-40c6-938b-505f51967a5d.png)
  
  - 예를 들면, 파드 안에 주 컨테이너는 특정 디렉터리 파일을 제공하는 웹 서버, 추가 컨테이너(사이드카 컨테이너)는 외부 소스에서 주기적으로 콘텐츠를 받아 해당 웹 서버의 디렉터리에 저장해야 할 경우
  
  - 로그 로테이터와 수집기, 데이터 프로세서, 통신 어댑터 등이 사이드카 컨테이너의 또 다른 예시

  - 파드 안에 여러 컨테이너를 사용하는 경우엔 다음 사항을 고려해야함
    - 컨테이너를 함께 실행해야 하는가, 혹은 서로 다른 호스트에서 실행 가능한가?
    - 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가, 혹은 개별적인가?
    - 컨테이너가 함께, 혹은 개별적으로 스케일링 되어야 하는가?
<br/> <br/> <br/>

## YAML or JSON 디스크립터로 파드 생성
    파드를 포함한 다른 쿠버네티스 리소스는 일반적으로 k8s REST API 엔드포인트에 JSON 혹은 YAML 매니페스트를 전송해 생성

    YAML 파일에 k8s 오브젝트를 정의하면 버전 관리 시스템에 넣을 수 있다.
<br>

### 파드 YAML 디스크립터 구조
Metadata, Spec, Status파드를 정의하는 주요 부분
- apiVersion: YAML 디스크립터에서 사용한 k8s API 버전

- kind: 쿠버네티스 오브젝트 / 리소스 유형

- Metadata: 이름, 네임스페이스, 레이블 및 파드에 관한 기타 정보를 포함
- name: 파드 이름

- Spec: 파드 정의/내용 (파드 컨테이너, 볼륨, 기타 데이터 등 파드 자체에관한 실제 명세를 가진다.)
- containers.iamge: 컨테이너를 만드는 컨테이너 이미지
- containers.name: 컨테이너 이름
- containers.ports.containerPort: 애플리케이션이 수신하는 포트
    - 컨테이너 포트는 생략 가능, 명시적으로 정의한다면, 클러스터를 사용하는 모든 사람이 파드에서 노출한 포트를 빠르게 볼 수 있다. (포트에 이름 지정도 가능)

- Status: 파드와 그 안의 여러 컨테이너의 상세한 상태이다. 각 컨테이너 설명과 상태, 파드 내부 IP, 기타 기본 정보 등 현재 실행 중인 파드에 관한 현재 정보를 포함
(새 파드를 만들 때 status 부분은 작성할 필요가 없다.)

- 팁
  - kubectl explain을 통해  오브젝트 필트의 정보를 알 수 있다. 
  - kubectl explain.pods로 pod에 대한 설명과 어떤 필드를 가지는지 볼 수 있고
  - kubectl explain.pod.spec 이렇게 사용해서 속성까지도 볼 수 있다.
<br/>
<br/>
 

### kubectl create
    kubectl create -f xxx.yaml 이런식으로 파드  생성 가능

- 실행중인 파드의 전체 정의 가져오기
  - 생성 후, k8s에 파드의 전체 YAML 요청 가능
  - YAML 대신 JSON을 반환하도록 할 수도 있음.

- 파드 목록에서 새로 생선된 파드 보기
  - kubectl get pods
    - 이름 / 준비 / 상태 / 재시작 / 나이를 알 수 있음

<br/><br/>


### 애플리케이션 로그 보기
    컨테이너화된 애플리케이션은 로그를 파일에 쓰기보다는 표준 출력/에러에 남기는 것이 일반적 사용자는 이걸 간단하게 볼 수 있음

    이 로그들의 스트림을 컨테이너 런타임이 파일로 전달

- kubectl logs (파드의 로그 보기)
  - ssh로 노드에 접속해서 봐도 되지만 kubectl logs {pod명}으로 실행
  
  - 다중 컨테이너 파드의 경우 kubectl logs {pod명} -c {컨테이너 명}으로 특정 컨테이너 로그만 확인 가능, 파드죽으면 해당 로그도 같이 삭제된다. (그 이후에도 보려면 중앙집중식 로깅을 설정해야 함)
<br/><br/>

### 파드에 요청 보내기 (포트 포워드) {new}
    파드 실행중 파드 실제 동작 보기 위해, 파드에 테스트와 디버깅 목적으로 연결할 수 있는 방법이 포트 포워딩
<br/>

- 로컬 네트워크 포트를 파드의 포트로 포워딩
  - 서비스를 거치지 않고 파드를 보고 싶을 때 k8s는 해당 파드로 향하는 포트 포워딩을 구성해 준다.

  - 포트 포워딩 구성은 kubectl port-forward
    - ex: kubectl port-forward {pod명} 8888:8080
    - 머신의 로컬 포트 8888을 위 pod의 8080 포트로 향하게 한다.

- 위 과정을 지나면 curl을 통해 http 요청을 해당 파드로 보낼 수 있음
  - ex: curl localhost:8888
  
  - 이런식으로 개별 파드를 로컬 머신에서 테스트 가능
<br/>
<br/>

## 레이블을 이용한 파드 구성 (파드 그룹화)
    수 많은 파드가 있을 경우? -> 파드를 정리하는 매커니즘이 필요

### 레이블 소개
- 레이블은 리소스에 첨부하는 key-value 쌍이다. 이 쌍은 레이블 셀렉터를 사용해 리소스를 선택할 때 활용.

- 레이블 키가 해당 리소스 내에서 고유하다면, 하나 이상 원하는 만큼 레이블을 가질 수 있다.


###
    Q. prometheus metadata는?
    Q. API 서버의 리소스는 마스터 노드 내에 있는건가? 이 리소스의 의미는?
