# 쿠버네티스 내부 이해

## 쿠버네티스의 동작에 대해 배울 예정.
- ex) 파드가 스케줄링되는 방법이나 컨트롤러 매니저 내에서 실행중인 다양한 컨트롤러가 리소스를 배포해 활성화 하는것


## 쿠버네티스 클러스터 구성 크게 보면~
- 쿠버네티스 컨트롤 플레인 → 일단 이게 우리가 생각하던 
- master node라고 봐도 될까? (워커)노드
 ![image](https://user-images.githubusercontent.com/38865267/133357529-5c5983aa-1695-4219-a968-e28e157b96e2.png)
- 쿠버네티스 시스템 구성 요소는 오직 API 서버하고만 통신한다.
<br/> <br/>

## 컨트롤 플레인 구성요소 4가지
<br/><br/>

### etcd 분산 저장 스토리지
- 클러스터 상태와 메타데이터를 저장하는 유일한 장소

- 둘 이상의 etcd 인스턴스를 사용하면 성능이 우수해진다.

- etcd는 etcdctl 명령어로 까볼 수 있는데 JSON 형식의 pod 정의란걸 알 수 있다.

- 합의 알고리즘 동작 (etcd를 여러개로 구성할경우 → 보통 홀수~)

- 클러스터가 다음 상태로 진행하기 위해 과반수가 필요
     ![image](https://user-images.githubusercontent.com/38865267/133355929-e2bc70dd-4b20-4964-9035-f484cf5c5aa8.png)
     <br/> <br/>

### API 서버
- 다른 모든 구성요소가 API 서버를 통해 클러스터의 상태를 업데이트 한다. 그래서 오류가 발생할 가능성이 줄고 항상 일관성을 가질 수 있다. 저장소에 기록된 데이터가 항상 유효해진다.

- 데이터 변경 또한 올바른 권한을 가진 클라이언트에 의해서만 수행되도록 한다.

- RESTful한 인터페이스를 제공한다.

- kubectl 명령도 API 서버의 client 중 하나이다.
     ![image](https://user-images.githubusercontent.com/38865267/133356098-55a15968-aed7-4211-a64c-2110422c62cf.png)
     <br/>
    - 인증, 인가 작업 거침

    - 어드미션 컨트롤 플러그인??   → READ는 안거친다~
        - 리소스 생성, 수정, 삭제 (서버는 여러 어드미션 컨트롤 플러그인을 사용한다.) 
  

    - 요청이 모든 어드미션 컨트롤 플러그인을 통과하면 API 서버는 오브젝트의 유효성을 검증, etcd에 저장, 클라이언트에 응답반환. <br/>
        <br/>
- API 서버가 리소스 변경을 클라이언트에 통보하는 방법
    - API서버는 컨트롤러와 다른 구성요소가 배포된 리소스의 변경사항을 관찰할 수만 있으면된다.
  
    - 컨트롤 플레인 구성 요소는 리소스가 생성, 수정, 삭제될 때, 통보를 받을 수 있도록 요청이 가능함.
  
    - 클라이언트는 API 서버에 HTTP 연결을 맺고 변경 사항을 상시 감지
  
    - 위와 같은 연결로 감시대상인 오브젝트의 변경을 알 수 있는 스트림을 받는다.
  
    - 오브젝트가 갱신될 때마다, 서버는 오브젝트를 감시하고 있는 모든 클라이언트에게 새로운 버전의 오브젝트를 보낸다.
    - kubectl 도구는 리소스 변경을 감시할 수 있는 API 서버의 클라이언트 중 하나다.
       ![image](https://user-images.githubusercontent.com/38865267/133356325-1877e5cf-474f-4a05-b2a4-c875711884a7.png) <br/><br/>
### 스케줄러
- 스케줄러는 선택된 노드에 파드를 실행하도록 지시하지 않는다. 스케줄러는 무조건 API 서버로 pod 정의를 갱신한다. 

- 스케줄러가 API 서버를 통해 pod 정의를 갱신하게 되고 API서버는 worker node의 kubelet에 Pod가 스케줄링된 것을 통보한다.

- 스케줄러는 무작위로 노드를 생성하는 단순한 방법부터 머신러닝을 쓰는 고급 스케줄링까지 다양하게 있다 쿠버네티스의 기본 스케줄러는 이 둘의 중간정도라고 보면된다.

- 스케줄링 알고리즘 <br>
    1. 모든 노드 중에서 파드를 스케줄링할 수 있는 노드 목록을 필터링
    2. 수용 가능한 노드의 우선순위를 정하고 점수가 높은 노드 선택, 점수가 같다면 라운드-로빈
        ![image](https://user-images.githubusercontent.com/38865267/133356562-ccd3bf65-ed66-40ef-8afc-df4dd07412a6.png) <br/> <br/>

- 고급 파드 스케줄링
  - 파드의 레플리카가 여러 개인 경우
    - 기본적으로 분산시켜야한다.
    - 어피니티, 안티-어피니티 규칙을 정의해 클러스터 전체에 퍼지거나 가깝게 유지되도록 강제할 수 있다.
<br/>
- 스케줄러에서 Selector 및 affinity(밀접한 관계) 추가정보
  - https://velog.io/@seunghyeon/Kubernetes-5.-%ED%8C%8C%EB%93%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81
<br>

### 컨트롤러 매니저

API 서버는 리소스를 etcd에 저장하고 변경사항을 클라이언트에 통보, 스케줄러는 파드에 노드할당
그럼 컨트롤러 매니저는 어떤역할?

- 우선 컨트롤러매니저 안에서 실행되는 컨트롤러에 의해 API 서버로 배포된 리소스에 지정된 대로 시스템을 원하는 상태로 수렴되도록 한다.

- 레플리카, 디플로이먼트, 노드, 서비스 등등 생성할 수 있는 거의 모든 리소스에 대한 수많은 컨트롤러가 존재한다. 실제 작업을 수행한다 해야하나?

- 컨트롤러의 역할과 동작 방식 이해

  - API 서버에서 리소스(deployment, service ..)들이 변경되는 것을 감시, 각 변경 작업을 수행하는 일을 한다. -> 리소스 생성, 갱신
  
  - 감시 매커니즘을 이용해 변경 사항을 통보 받으며 정기적으로 누락된 이벤트가 없는지 확인한다.
  
  - 각 컨트롤러에는 일반적으로 Informer를 만드는 생성자가 있다. Informer는 API 오브젝트가 갱신된 내용을 받을 때마다 호출되는 리스너다. 생성자를 보면 컨트롤러가 어떤 리소스를 감시하는지 볼 수 있다.

- 레플리케이션 매니저
  - 레플리케이션 컨트롤러 리소스를 활성화하는 컨트롤러
  
  - 매니저가 실제 작업을 수행
  
    1.  레플리케이션 컨트롤러는 무한 루프를 도는데 루프를 돌 때마다 컨트롤러는 파드 셀렉터와 일치하는 파드의 수를 찾고 이를 원하는 레플리카 수와 비교한다.
   
    2. 컨트롤러가 호출 되었을 때, 원하는 레플리카 수와 실제 레플리카 수를 다시 확인하고 그에 맞는 동작 수행
   
    3. 레플리케이션 컨트롤러는 동작할 때, 새로운 파드 매니페스트를 생성해 API 서버에 알리고 API 서버의 통보를 받은 스케줄러가 스케줄링, kublelet이 실행작업을 수행한다. <br/>
   
- 레플리카셋, 데몬셋, 잡 컨트롤러

  - 레플리카셋 컨트롤러는 레플리케이션 매니저와 거의 동일한 기능 수행
  
  - 데몬셋, 잡 컨트롤러는 리소스에 정의된 파드 템플릿에서 파드 리소스를 생성, 당연히 컨트롤러들은 직접 작업을 하는게 아니라 API 서버에 명시만한다.

- 디플로이먼트 컨트롤러

  - 실제 배포된 전체 상태와 deployment API 오브젝트에 기록된 상태를 동기화 한다.
  
  - 만약 deployment 오브젝트가 수정되어 이미 배포되어 있는 pod에 영향을 준다면 새로운 버전을 롤아웃.
  
- 스테이트풀셋 컨트롤러
  
  -  스테이트풀셋 리소스 정의에 따라 파드 생성, 관리, 삭제
  
  -  다른 컨트롤러가 파드만 관리하는 반면, 얘는 각 파드 인스턴스를 위한 퍼시스턴트 볼륨클레임도 인스턴스화 하고 관리.

- 노드 컨트롤러
  - 워커 노드를 기술하는 노드 리소스 관리, 실행 중인 실제 목록과 노드 오브젝트 목록을 동기화 하는데 중점.

  - 노드의 상태를 모니터링, 만약 연결이 끊어진 노드에선 파드를 제거한다.

- 서비스 컨트롤러
  - LB 서비스가 생성되거나 삭제될 때 인프라스트럭처에 로드 밸런서를 요청하고 해제하는 역할을 수행

- 엔드포인트 컨트롤러
  - 레이블 셀렉터와 일치하는 파드의 IP와 포트로 엔드포인트리스트를 계속 갱신하는 구성요소

  - 서비스와 파드 모두를 감시하며 이것들이 추가, 갱신, 삭제될 경우 파드 셀럭터와 일치하는 파드를 선택해 IP와 포트를 엔드포인트 리소스에 추가한다.
   ![image](https://user-images.githubusercontent.com/38865267/133375625-0936fe15-667e-486e-9061-8fa23ddf885e.png)
   <br/>

- 네임스페이스 컨트롤러
  - 네임스페이스의 삭제에 따라 API 서버를 통해 네임스페이스에 속해 있는 모든 리소스를 삭제

- 퍼시스턴트볼륨 컨트롤러
  - 퍼시스턴스볼륨 클레임이 있을 때, 요청한 접근 모드와 일치하는 퍼시스턴트 볼륨을 찾고 그 중 용량이 가장 작은 볼륨을 선택한다.
  
  - 사용자가 클레임을 삭제하면 해당 볼륨은 연결이 끊어지고, 볼륨회수 정책에 따라 그대로 남겨두거나 회수된다.



<br/><br/>

## 워커노드 구성요소

### kubelet
api 서버에서 pod가 스케줄링 된 것을 통보 받으면 kublet이 이걸 확인하자마자 Pod의 컨테이너를 생성하고 실행한다.
kubelet과 서비스 프록시는 실제 pod 컨테이너가 실행되고 있는 워커 노드에서 실행
<br/>

- kubelet의 작업 이해
  - 워커 노드에서 실행하는 모든 것을 담당하는 구성요소
    1. kubelet이 실행 중인 노드를 노드 리소스로 만들어 API 서버에 등록
    2. API 서버를 지속적으로 모니터링하여 해당 노드에 pod가 스케줄링되면 파드의 컨테이너를 시작
    3. 컨테이너 런타임에 지정된 컨테이너 이미지로 컨테이너를 실행
    4. 실행 중인 컨테이너를 지속 모니터링하며 상태, 이벤트, 리소스 사용량을 API서버에 보고
    5. API 서버에서 Pod가 삭제될 경우 컨테이너를 정지하고 파드 종료를 서버에 통보

<br/>

- API 서버 없이 정적 파드 실행
  - kubelet은 특정 로컬 directory 안에 있는 매니페스트 파일을 기반으로 파드를 실행할 수도 있다. -> 이런 경우엔 데몬셋을 사용하도록 하자


<br/><br/>

### 쿠버네티스 서비스 프록시 (kube-proxy)
kube-proxy는 서비스의 IP와 포트로 들어온 접속에 대해 서비스를 지원하는 Pod 중 하나와 연결 시켜준다. (만약 서비스가 둘 이상일 경우엔 LB)
<br/>

- 서비스와 관련된 모든 것은 각 노드에서 동작하는 kube-proxy 프로세스에 의해 처리된다.

- 두 가지 모드
  - userspace 프록시 모드: 라운드로빈 방식이며 패킷이 kube-proxy 통과, 이를 사용자 공간에서 처리
    - 초기에 나온 개념, kube-proxy가 실제 프록시로서 연결을 기다리다가, 들어온 연결을 위해 해당 파드로 가는 새로운 연결을 생성

  - iptables 프록시 모드: 랜덤, 패킷을 커널 공간에서 처리
    - 사용방법
      1. API 서버에서 서비스를 생성하면, 가상 IP 주소가 바로 할당
      2. API 서버는 위커 노드에서 실행 중인 모든 kube-proxy 에이전트에 새로운 서비스가 생성됐음을 통보
      3. 각 kube-proxy는 실행 중인 노드에 해당 서비스 주소로 접근할 수 있도록 만듬, 서비스의 IP/port로 향하는 패킷을 가로채서 목적지 주소를 변경한다.
  
- 각 서비스는 안정적인 IP 주소와 port를 얻는데, 클라이언트(pod)는 이 가상 IP 주소와 포트를 이용해 서비스에 접속해 사용, 서비스 IP 만으로는 아무것도 나타나지 않음
  
- kube-proxy는 API 서버에서 서비스 변경을 감지하는 것 외에도 엔드포인트 오브젝트가 변경되는 것을 같이 감시, 여기서 엔드포인트 오브젝트는 서비스를 지원하는 모든 pod의 IP/port 쌍을 가지고 있다.
  
- 엔드포인트 옵젝 변경 예시는 파드 생성 및 삭제, 파드의 readiness 상태 변경, 파드 레이블 수정

<br/>


### 쿠버네티스 애드온
항상 필요하진 않지만 활성화 할 수 있다.
k8s 서비스의 DNS 조회, 여러 HTTP 서비스를 단일 외부 IP주소로 노출, k8s 웹 대시보드와 같은 것들이 있다.
<br/>

- 애드온 배포 방식
  - 위 예시의 구성 요소는 애드온으로 제공, yaml 매니페스트를 API 서버에 게시해 pod로 배포

  - 일부는 deployment 리소스, 레플리케이션 컨트롤러 리소스로 배포되고 일부는 데몬셋으로 배포
<br/>

## DNS 서버
동작 방식
- 클러스터 내 모든 Pod는 기본적으로 클러스터의 내부 DNS 서버를 사용하도록 설정

- 이걸로 pod는 서비스를 이름으로만 쉽게 찾을 수 있고 headless 서비스 파드인 경우 해당 파드의 IP 주소를 조회할 수 있다.

- DNS 서버 파드는 kube-dns 서비스로 노출되므로, 해당 파드를 다른 파드와 마찬가지로 클러스터 안에서 이동할 수 있다.
- 해당 서비스의 IP주소는 클러스터에 배포된 모든 컨테이너가 가지고 있는 etc/resolv.conf 파일 안에 nameserver로 지정되어 있음.
- kube-dns Pod는 API 서버 감시 매커니즘을 이용해 서비스와 엔드폰인트 변화를 관찰 및 DNS 레코드에 갱신 -> 이로 클라이언트가 거의 항상 최신 DNS 정보를 얻을 수 있다.<br/>
<br/>

### 인그레스 컨트롤러 동작 방식
- DNS 애드온과 달리 인그레스 컨트롤러 구현체가 존재하나 대부분 같은 방식으로 동작

- 인그레스 컨트롤러는 리버스 프록시 서버(nginx)를 실행하고 클러스터에 정의된 인그레스, 서비스, 엔드포인트 리소스 설정을 유지

- DNS 서버와 인그레스 컨트롤러 애드온은 API 서버로 리소스 변경을 관찰, 수정하는 것 뿐만 아니라 클라이언트의 연결을 수락하는 역할도 한다.

<br/><br/>

## 용어 정리
- 매니페스트: 메타데이터
- 오브젝트: 실제 개체?
- 리소스: API 서버에 담겨있는 것 같다. yaml파일로 만든 deployment같은 애들 근데 실체인 pod라고 보긴 애매함, 어찌보면 노드에 올라가지 않은 상태의 pod, deployment, 레플리카셋이 아닐까?
- 노드: 워커노드 말하는건가...
- 클라이언트: pod?